#+HUGO_BASE_DIR: ../../
#+HUGO_SECTION: post

#+HUGO_AUTO_SET_LASTMOD: nil

#+TITLE: Guix to manage project dependency

#+DATE: 2021-01-02

#+HUGO_TAGS: "Guix" "Functional Package Manager" "Reproducibility"
#+HUGO_CATEGORIES: "Guix"
#+AUTHOR:
#+HUGO_CUSTOM_FRONT_MATTER: :author "Peter Lo"

#+HUGO_DRAFT: true

This is a brief introduction to the Guix functional package manager,
and how it could be used to manage dependencies of projects, much like
virtual environments for Python, but with much larger scope.

# summary

* What is Guix?

** Guix: functional package manager
Guix has the following characteristics:
   - [[https://guix.gnu.org/][Guix]] is in fact a package building system, being a good package manager is a side effect
     - inspired by the [[https://nixos.org/][Nix]] functional package manager
       - which is in turn partly inspired by functional programming, and by [[https://wiki.gentoo.org/wiki/Main_Page][Gentoo]]'s package management
     - to make the package building be a /pure function/ and therefore more easily reproduced
   - designed to properly address the "dependency hell" problem
   - aim at reproducible builds
     - the /exact/ same set of packages could be reproduced at a later time or on a different machine (of the same architecture), by just using two small text files
   - allows atomic installation/uninstallation/upgrade of packages
     - each action is a *transaction*, i.e. either it succeeds as a whole, or does not succeeds, there would not be half installed packages
   - allows easy rollback of install/uninstall actions
     - each transaction results in new generation
     - can easily rollback to previous generations
     - so there is little fear of accidentally installing/uninstalling/upgrading the wrong packages
   - allows different versions of the "same" package to coexist and used by different pakcages, without conflict
   - encourages declarative package management
     - a set of packages can be specified in a *manifest file*, and can be installed in one transaction
   - currently only works on GNU/Linux
     - can be installed on any GNU/Linux distribution such as Debian, Ubuntu, Arch, etc
     - can coexist with the existing package manager of the distribution
   - allows each user to manage his/her own packages
     - without root privilege
     - without interferring other users
   - each user can have multiple *profiles* of packages
     - each profile has its own list of generations, and can be rolled back separately
   - allows easy creation of isolated environments with designated packages
   - *Guix system* is a GNU/Linux distribution built on top of the Guix package manager
     - use a config file to declaratively specify the whole system, e.g. the system services, user accounts, etc


At this point, you may not think these characteristics are special if
you have not experienced the pains brought by dependency
management. Hopefully after reading this post you will have better
appreciation of why a package manager is useful and why Guix is a good
one due to these good characteristics.

** Basic concepts of packages and dependency
We first list out some concepts related to packages and dependency:
   - *package*:
     - loosely speakinig, a package is a collection of functionality that we are interested in, e.g.
       - a library of functions, e.g. the [[https://www.tidyverse.org/][tidyverse]] R package
       - some applications, e.g. the [[https://www.mozilla.org/en-US/firefox/browsers/][firefox]] web browser
       - command line programs, e.g. the [[https://github.com/BurntSushi/ripgrep][ripgrep]] command for fast grep search on contents of files
       - or just a set of documentation files
   - *package building*:
     - the final files in a package are often produced through a /building/ process from some sort of /source/ files
     - e.g.
       - =ripgrep= is written in the [[https://www.rust-lang.org/][Rust programming language]], and would need a Rust compiler to produce the program
       - some pdf documentations may be produced through the [[https://www.latex-project.org/][Latex]] typesetting system
       - an R package needs to be built, see https://bookdown.org/rdpeng/RProgDA/building-r-packages.html
     - some packages are very flexible, and allow specifying different options when building, resulting in functionally slightly different packages
       - e.g. some functions may be left out if it is considered not useful
       - e.g. some function could be provided by different *dependent packages*
     - building script:
       - most packages have some building process (e.g. a script or a makefile)
     - building environment:
       - some packages will automatically detect its environment to change building options
       - e.g. if some other package is absent, some functionality will be left out, but the building will still succeed
       - therefore, if the building environment is not properly isolated, the "same" building script may still result in different built package, depending on what other packages are present in the system
       - this is similar to programming where the output of a "function" depends not only on its inputs, but also on other global variables
   - *package version*:
     - strictly speaking, package version is just a name attached to a package, and the name could theoretically be arbitrary, although most package authors follow some conventions
     - e.g. a lot of packages follow the [[https://semver.org/][Semantic versioning]], briefly
       - a version number consists of three numbers, in the format of "MAJOR.MINOR.PATCH", e.g. "1.0.4", where each should be increment as follows
         - MAJOR: when you make incompatible API changes, where MINOR and PATCH could be reset to 0, e.g. from "1.2.3" to "2.0.0"
         - MINOR: when you add functionality in a backwards compatible manner, where PATCH could be reset to 0, e.g. from "1.2.3" to "1.3.0"
         - PATCH: when you make backwards compatible bug fixes, e.g. from "1.2.3" to "1.2.4"
     - NOTE:
       - normally, different versions will have some differences, although they may be small, or supposed to be /backward compatible/.
       - even for the same vesion number, the package may be functionally different if built differently, as mentioned above.
   - *dependency*:
     - loosely speaking, if a package A needs another package B to provide some functionality, then A /depends/ on B, i.e. B is a /dependency/ of A.
     - *direct/indirect dependency*:
       - often a package will list out its needed dependencies (possibly also the range of allowed versions of each dependency), either formally in some fixed format, or informally as free text in some readme
       - *direct dependency*: the dependencies listed for a package
       - *indirect dependency*: not direct dependency, but are (direct or indirect) dependencies of the direct dependencies
       - Why the distinction of direct and indirect dependency? Both are needed to fully capture the dependencies.
         - the distinction is useful mainly when the dependency updates
         - if package A directly depends on package B, presumably the developers of A knows which functionality of B is needed
         - if B is updated to B1, then the developers of A need only check whether the needed functionality is still provided by B1, and act accordinly, rather than checking each of the dependencies of B and B1 to see which are still needed.
     - *build-time/run-time dependency*:
       - *build-time dependency*: dependency needed for building a package
         - e.g. a particular version =gcc= for compiling a program
         - e,g, *statically linked libraries*, i.e. those compiled into the program, so are needed at build-time
         - a build-time dependency may or may not be needed when the program is later run
       - *run-time dependency*: dependency needed for using the package, e.g. running the application
         - e.g. the *dynamically linked libraries*, i.e. the libraries will be loaded only when the program is run
         - nowadays, most programs use mostly dynamically linked libraries
         - NOTE: a dependency can be both build-time and run-time dependency
     - *optional dependency*: dependency that can be omitted for the package to build or run, but some functionality may be missing
       - e.g. [[http://www.inkscape.org/][inkscape]] can be built without the optional dependency =potrace=, just without bitmap tracing functionality.
       - in most *package manager* which mainly distribute binary packages, often most optional dependencies would be included to provide the most funcitonality
   - *dependency hell*:
     - roughly speaking, [[https://en.wikipedia.org/wiki/Dependency_hell][dependency hell]] refers to the problems caused by the dependency on specific versions of some packages.
     - dependency hell takes a few forms:
       - too many or long chains of dependencies:
         - this is only a problem if the dependencies have to be hunted down manually, which could become tedious very quickly
         - most package managers solve this by installing the dependencies when a package is installed
       - conflicting dependencies:
         - in many package manager (and default in dynamic library in Linux), minor versions are considered backward compatible, and for each package of the same major version, only the newest minor version is kept/used
         - if both package A and B depend on a package C, but A and B needs different minor versions of C to work correctly, then A and B have conflicts
         - this may happen if B is updated to B1 causing C to be updated to C1, therefore causing A to break, even if the older versions of the 3 packages previously coexisted and worked correctly.
         - in this case, it is clear that if we just let A to use the old C, and the new B1 to use the new C1, then A can work as before, and B can still be updated to B1.
   - ways that code of package A can break if a dependency B updates to a supposingly /backward compatible/ minor version:
     - although most of the time updating a minor version does not cause problem, they might still cause breakage
     - e.g. suppose A depends on a function in B, there could be a few cases:
       - the function interface remains unchanged or adds optional parameters, but the implementation is changed:
         - A may rely on undocumented behavior of the function, which has changed in the new implementation, although the documented interface is still the same.
           - e.g. the old implementation may sort the output as a side effect, but not promised in the function interface, and A may have relied on the sorted order
         - the new implementation may have buggy edge case, causing A to break
         - the new implementation may expose a buggy edge case in A, causing A to break
   - *reproducible build*
     - it is desirable to have the /exact same versions/ of dependencies between testing and production systems, and preferably also for the development environment
     - it is therefore desirable to /reproduce/ the exact same set of packages on a different machine (of the same architecture) and/or at a different time
     - this could be achieved in two main ways:
       - record the set of versions of the (pre-built) packages, and reinstall when needed
         - e.g. python virtual environment mostly follow this paradigm
       - record the set of versions of the packages, and rebuild then when needed
         - this is similar to the previous one, with the difference that the package can be built from scratch if needed
         - e.g. Guix can rebuild package(s) through the set of package definitions with explicit dependencies information
           - Guix can simply download the pre-built package (called /substitute/ in Guix) when available
       - record the set of built packages and just copy them as a whole when needed
         - e.g. building a docker image to contain all needed packages
     - isolated building environment can help with reproduciblity
       - only the explicitly listed dependencies are visible in building, so that the building script will not depend on other packages unknowingly
   - reproducibility raises the question of /sameness/ of packages
     - the package name with version number /would be/ sufficient if each version if always built the same way with the same versions of dependencies
       - this is the strategy adopted by most package managers
     - a better way is to use the package name together with some kind of *hash*
       - not necessarily the hash /of/ the package itself, as we will see in later sections
       - but different contents of a package should produce different hashes
   - *hash*:
     - basically a (very large) integer calculated through a *hash function* on some input, e.g. a file
     - the calculated integer is in some fixed range, often written as a long hexadecimal string such as "730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525"
     - the input however often has not length limit
     - e.g. [[https://en.wikipedia.org/wiki/SHA-2][sha-256]], [[https://en.wikipedia.org/wiki/MD5][md5]]
     - desired properties of a good *hash function*:
       - the same input always produce the same hash, i.e. it is a /pure function/ in the mathematical sense
         - i.e. if two inputs produce different hashes, they /must be/ different
       - it is one-way
         - there is not efficient way to recover the original content just from the hash, other than trying all possible input to find those that give the same hash
       - even a slight change in the input causes drastically different hash
         - useful for identifying corruption or tampering of files
       - /low/ collision, i.e. different inputs /should/ produce different hashes
         - it is impossible to have /no/ collision unless the set of possible inputs is less than the set of possible outputs
     - note that one hash is enough to represent a web of connected things:
       - e.g.
         - if you have a few (ordered) inputs, you hash each of them, and write the hashes to a file, then you hash this file
         - this is still a deterministic hashing process
         - if any of the input is changed, its calculated hash will /most probably/ be different, so this file of hashes will be different, and consequently the final hash will be different
         - each of the input itself could contain hashes of more inputs recursively, so a web of things could be represented as one hash
         - this technique is also used in [[https://git-scm.com/][git]] version control system to link the commits together
         - the same technique could be used to hash the (direct) dependencies of a package, and therefore one hash could represent all the direct and indirect dependencies of a package

* Why bother with Guix? There are other ways to handle dependency
Although there are a lot of package managers at both the language level and operating system level, and tools such as docker to help tackle the dependency problem, Guix still has merits when compared to these, as we now discuss.

** Use opearting system package managers
  - e.g. apt, yum, pacman
  - these package managers resolve dependencies for you, some allows pinning particular versions of package
  - sometimes language specific packages is also packaged
  - downsides:
    - these package managers mostly operate by /mutating/ the system state when adding or removing packages, so may not be easy to revert to previous state in case installing/upgrading some packages causes problem
      - if the process is interrupted, the system might be in an inconsistent state
      - installing/upgrading package may cause some dependencies to be updated, which might break other packages
      - subsequently removing that package does not necessarily revert the updated dependencies
    - since installing/upgrading package may cause dependencies to be updated, which may cause conflicts if some packages need older versions of the dependencies
      - although this is not common, this could be painful when happens
      - this is problematic often when you want newer version of some package, but older version of another package, and they (or their chain of dependencies) somehow have version conflicts
  - upsides of Guix:
    - Guix can be used just like the usual system package manager, although there are better ways of using it for specific needs
    - every install/remove/upgrade packages action (which may involve multiple packages) is one /transaction/, and causes a /generation/ to be created
      - Guix can detect and remedy interrupt of the action to maintain transactional behavior, i.e. either it succeeds or fails as a whole, so that the system would not be in a half-completed inconsistent state.
        - if an action is interrupted, it has not succeeded, and can be safely repeated
        - but in case an action involves multiple packages, a completely downloaded or built package need not be re-built or re-downloaded when the action is repeated, since they would be cached (in a /store/ where only the Guix daemon can modify) and identified by hash.
      - a /generation/ is essentially a record of the set of specific packages and their dependencies, so it is easy to revert to previous generation
        - all the packages and dependencies referenced by a generation would be kept in the system
        - so normally removing packages in Guix simply results in a generation without those packages, the packages themselves are still in the system cache, this is similar in spirit to git where a commit "deletes" some files.
        - reverting to other generation involves only updating some symbolic links, so are quick
        - the user safely try out different versions of some packages, knowing that it is easy to revert to previous known good state if the user dislike the version for whatever reason (e.g. bugs, different UI, missing features, etc)
        - the user can optionally delete older generations, and do a /garbage collection/ to really delete any unreferenced (directly or indirectly) packages to free up disk space
    - each package in Guix literally has its dependencies hard-coded using absolute paths to the dependeny in the /store/
      - each package in Guix is cached in a /store/ with a path with some sort of hash to identify the exact version of the package
      - therefore an updated package may also have updated dependencies, but older versions of the package or other packages still refer to their previous versions of dependencies fixed at built time
      - therefore there is no fear that updating a package will break another package just because they share some dependencies with conflicting versions
      - also, two packages with conflicting dependencies can coexist in Guix because each can have their own versions of dependencies
** Use language specific package manager such as pip, packrat, npm, etc
  - many programming languages have their own package manager, because the system package manager may not have these language-specific packages, and having a language specific one would be more uniform across different operating systems or Linux distributions
  - e.g.
    - pip for Python
    - =install.packages()= for R
    - npm for Javascript
    - RubyGems for Ruby
    - Cabal for Haskell
  - for better management of possibly difference packages for different projects, there are either some sort of /virtual environment/, or some kind of /lock files/ to pin-point the versions of set of packages for each project, e.g.
    - [[https://github.com/pyenv/pyenv#simple-python-version-management-pyenv][pyenv]], [[https://virtualenv.pypa.io/en/stable/][virtualenv]], [[https://docs.continuum.io/anaconda/packages/pkg-docs/][anaconda]] for Python, see [[https://stackoverflow.com/a/39928067]] for a brief comparison
    - [[https://rstudio.github.io/packrat/][packrat]] or [[https://rstudio.github.io/renv/][renv]] for R
    - rubygems, npm and cabal have lock files
  - downsides:
    - these language-specific package managers naturally only handles packages for on programming language
      - if a project uses only one programming language, e.g. Python, then either one of the virtual environment manger may be sufficient
      - but if the projects in the same team use multiple programming languages, e.g. both Python and R for data science projects, then the users would need to be familiar with multiple package managers
    - these package managers may not help with system-level dependencies, especially when pre-built binary package is not available (e.g. R packages under Linux) and the package needs to be built
    - some dependencies are not managed by these virtual environments
      - e.g. packrat, being an R library, does not help manage the version of R itself
        - although this is often ok because R is usually backward compatible, but sometimes there could be issues, e.g. see https://github.com/rstudio/packrat/issues/327
      - in contrast, virutal environments in Python can also manage different versions of Python, because there are bigger differences between versions of Python
    - the virtual environments are often setup per-project, but identical packages (and dependencies) may be duplicated instead of shared, taking up more disk space than necessary (unless the filesystem had built-in support for deduplication)
      - e.g. packrat for R install a copy of the needed packages for each project
      - in contrast, renv for R has a global shared cache of packages, so that identical packages can be shared for different projects, see https://cloud.r-project.org/web/packages/renv/vignettes/renv.html
  - upsides of Guix:
    - Guix has system-level libraries, applications, language specific pakcages all at the same level, and can be managed in the same way.
      - e.g. =r-tidyverse= is the Guix package for the R [[https://www.tidyverse.org/][tidyverse]] package, which depends on many other R packages, all of can also be managed by Guix
      - e.g. =python-numpy= is the Guix package for the Python [[https://numpy.org/][numpy]] package, which depends on =gfortran@7.5.0= (version 7.5.0), =lapack@3.9.0=, =openblas@0.3.9=, =python-cython@0.29.21= and =python-pytest@5.3.5=
      - e.g. =r-xml= is the Guix package for the R [[https://cran.microsoft.com/web/packages/XML/index.html][xml]] package, which (as of this writing, at version 3.99-0.5) depends on libxml2@2.9.10, pkg-config@0.29.2 and zlib@1.2.11, but these libraries are managed by Guix in the same way as any other dependencies
      - the philosophy of Guix is really to manage as many dependencies as sensible, e.g. =emacs-projectile= is the Guix package for the [[https://docs.projectile.mx/projectile/index.html][projectile]] package of the [[Emacs][GNU Emacs]] text editor
      - Guix can also mange R itself as a package, so the R version can also be managed just as any other packages in your project
      - therefore, Guix can handle dependencies across multiple programming language, and mixing with system level dependencies
    - all Guix packages are put in =/gnu/store=, with a path having the name and a hash, e.g. =/gnu/store/9naz5xl42amla3ph860yxxqrk9420nvr-r-tidyverse-1.3.0= for the =r-tidyverse= currently on my system
      - this store is only modifiable by the Guix daemon, and are read-only for normal users
      - by virtue of the nice properties of the hash, this path serves as a unique identity of package, even if they have the same version number
        - e.g. currently on my system, I find three Python 3.8.2 packages with different hashes, which are probably dependencies of other packages, and are built with slightly different settings:
          - =/gnu/store/09a5iq080g9b641jyl363dr5jkkvnhcn-python-3.8.2=
          - =/gnu/store/jxx8fr78jrcvpid5aplmkplbm1dk6czs-python-3.8.2=
          - =/gnu/store/q9rm8h9imazsq2c4qiv2yjpvlvliywqb-python-3.8.2=
      - therefore, the exact same package (as identified using the path) can be shared, while different versions (even with the same version number) can coexist
      - also, when installing packages, if the exact package is also in the store, it need not be downloaded/built again
    - Guix can manage per-project dependencies, similar to a virtual environment or a per-project lockfile
      - a list of packages can be recorded in an /manifest/ file, which is a plain text file that can be easily version-controlled
      - e.g. an manifest file for some R packages may look like this (this is in fact [[https://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]] code, because Guix is implemented as a /domain specific language/ in [[https://www.gnu.org/software/guile/][Guile]] implementation of Scheme):
        #+begin_src scheme
          (specifications->manifest
            '(
              ;; R
              "r"
              "r-yaml"
              "r-xgboost"
              "r-tidymodels"
              "r-tidyverse"
              "r-survminer"
              ))
        #+end_src
      - the manifest file is declarative, and simple enough that it can be easily maintained even by manually editing as needed
      - note that the manifest file only contains the names of the packages, but not the explicit versions
        - so by itself, it cannot pin-point the exact versions of the packages (and their dependencies)
        - each (specific version) of package is described by a package definition
          - e.g. the package definition for =r-xgboost= (version 1.2.0.1) is:
            #+begin_src scheme
              (define-public r-xgboost
                (package
                  (name "r-xgboost")
                  (version "1.2.0.1")
                  (source
                   (origin
                     (method url-fetch)
                     (uri (cran-uri "xgboost" version))
                     (sha256
                      (base32
                       "16hpvv2hwdzcyg90z7c1g5d2hj011qk8mivy4l2nqd2g7rkjwis4"))))
                  (build-system r-build-system)
                  (propagated-inputs
                   `(("r-data-table" ,r-data-table)
                     ("r-magrittr" ,r-magrittr)
                     ("r-matrix" ,r-matrix)
                     ("r-stringi" ,r-stringi)))
                  (native-inputs
                   `(("r-knitr" ,r-knitr)))
                  (home-page "https://github.com/dmlc/xgboost")
                  (synopsis "Extreme gradient boosting")
                  (description
                   "This package provides an R interface to Extreme Gradient Boosting, which
              is an efficient implementation of the gradient boosting framework from Chen
              and Guestrin (2016).  The package includes efficient linear model solver and
              tree learning algorithms.  The package can automatically do parallel
              computation on a single machine.  It supports various objective functions,
              including regression, classification and ranking.  The package is made to be
              extensible, so that users are also allowed to define their own objectives
              easily.")
                  (license license:asl2.0)))
            #+end_src
          - we see that it contains information on:
            - where to fetch the source files: =(uri (cran-uri "xgboost" version))=
            - the sha256 hash of source file: the =(sha256 (base32 ...))= part to aid reproducibility
            - the way to build the package: =r-build-system= is used here for a typical R package
            - the built-time dependency: =(native-inputs `(("r-knitr" ,r-knitr)))=
            - the run-time dependencies: =(propagated-inputs ...)= or =(inputs ...)= (see https://guix.gnu.org/manual/en/guix.html#package-Reference for details of the difference between the two)
            - other auxiliary information which are not really essential, but nice to have
          - the set of all these package definitions is managed with git repository
            - they are managed as /channel/, which is git repository with some meta-data
            - there is an official repository at https://git.savannah.gnu.org/git/guix.git
            - user can create their own repository for their own modification or private packages that they would not like to share with outsiders
            - the particular commit(s) of the channel(s) in your system /determine/ which exact versions of the packages when installed, reproducibly
          - the current commit(s) of channel(s) can be exported to a plain text file by Guix, e.g.
            #+begin_src scheme
              (list (channel
                      (name 'guix)
                      (url "https://git.sjtu.edu.cn/sjtug/guix.git")
                      (commit
                        "2283baae907f4f38a8299d47ba4c0b2b49222883")
                      (introduction
                        (make-channel-introduction
                          "9edb3f66fd807b096b48283debdcddccfea34bad"
                          (openpgp-fingerprint
                            "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA")))))
            #+end_src
          - Guix also provides /time-machine/ to conveniently use particular commit(s) of channel(s) (in the form as exported above) for any Guix actions, see [[https://guix.gnu.org/manual/en/guix.html#Invoking-guix-time_002dmachine][Invoking guix time-machine]]
          - therefore, by keeping two easily version-controlled plain text files (the manifest file for packages and the exported channel description), a set of particular versions of packages can be recorded reproducibly
      - there are a few ways to use the manifest file (and can be used together with channel description through time-machine for maximum benefits), in fact a manifest file is only a convenient way to specify a list of packages, so can be used for different commands of Guix:
        - install the specified packages in one transaction (on the default profile of the user):
          - this is inconvenient for managing different sets of packages for different projects, because the actions are applied to the default profile of the user
          - there are better ways for managing per-project packages
        - a better way is to install the specified packages in a separate profile for the project:
          - each user can create multiple profiles in addition to the default one, and each profile can has a separate set of packages and its own sequence of generations
          - each profile can be activated as needed, much like a virtual environment in Python
          - the Guix install/upgrade/remove actions can be applied to specified profile, see the =-p= option of [[https://guix.gnu.org/manual/en/guix.html#Invoking-guix-package][Invoking-guix-package]] for details
          - but the downside is that when the set of packages in the manifest file is changed, the user need to remember to reapply the manifest file to the chosen profile to update the set of packages
          - if the packages for each project are rarely changed, using profiles can be a reasonable way of managing per-projet packages, but there is still a better way
        - spawns a new shell with the specified packages accessible in the =PATH=, by using =guix environment=:
          - =guix environment= is a powerful and flexible command in Guix
            - we can choose to have the packages themselves be accessible in the shell, by placing the list of packages or using the =-m= option for manifest file after the =--ad-hoc= option
            - or we can choose to have the direct dependencies of the packages be accessible, or both
              - having the dependencies be accessible is useful for developing a package, because we may need the dependencies for test building the package and tweak as neede
            - we can either have an interactive shell with the needed packages accessible,
            - or we can directly execute a command in the new shell by placing the command (and the arguments) after a =--= at the end of the list of packages
            - can choose to have only the specified packages be accessible in the new shell by using the =--pure= option, the default is to augment current =PATH=
            - can even choose to run the command inside an isolated container, which uses the isolation capability of the Linux kernel in a similar way to docker containers
            - of course this can be combined with guix time-machine
            - =guix environment= is basically creating a temporary profile, so would not "pollute" or clutter the default profile when the shell exits or the specified command ends
            - the specified packages will be downloaded/built if they are not already in the cache
            - see [[https://guix.gnu.org/manual/en/guix.html#Invoking-guix-environment][Invoking-guix-environment]] for more details of other useful options
          - therefore, we can spawn a new shell with needed packages each time we work on a project, we won't forget to reapply the manifest file
          - e.g. to work on a project, suppose in a R project directory
            - there is a manifest file =pkgs.scm= specifying the packages (including R itself),
            - and there is an exported channel description file =channels.scm= containing the commits of the channels
            - when we want to work on the project, we can type in the shell
              #+begin_src shell
                guix time-machine -C channels.scm -- environment --ad-hoc -m pkgs.scm
                # then in the new shell, start R
                R
              #+end_src
            - or you can do it in one line:
              #+begin_src shell
                guix time-machine -C channels.scm -- environment --ad-hoc -m pkgs.scm -- R
              #+end_src
            - the first time running this may take a while if the packages are not yet downloaded/built in your system, but subsequent runs should be much quicker because the packages are already cached
            - moreover, these =pkgs.scm= and =channels.scm= files can be committed to version control system (e.g. git) together with other project files
              - they are project dependencies, which are logically part of the project, so in my opinion should also be committed
              - then everyone working on the project would be using the same versions of packages for the same commit
              - if these two files are changed, the correct versions of the needed packages would be prepared by Guix the next time you work on the project
            - of course, typing this long line each time is tiresome, so we can make an alias in your shell (e.g. by adding this to your =.bashrc= or =.bash_profile=) to reduce some typing, e.g.
              #+begin_src shell
                alias work="guix time-machine -C channels.scm -- environment --ad-hoc -m pkgs.scm"
              #+end_src
              then you can just type
              #+begin_src shell
                work -- R
              #+end_src
            - working with Python project, or any other language is similar, just make sure you have the needed packages in the =pkgs.scm= file.
            - one thing that I have not yet investigated deeply enough:
              - of course, we usually use some development tools such as IDE or text editor that are usually personal preferences, so they should not be put into =pkgs.scm=, but should better be installed in the default user profile
              - e.g. for R, common choices are [[https://rstudio.com/][RStudio]], [[https://www.gnu.org/software/emacs/][Emacs]] with [[https://ess.r-project.org/][ESS]], [[https://www.vim.org/][Vim]], [[https://code.visualstudio.com/][VSCode]]
              - you would need some way to make these tools see and use the R in the newly spawned shell, which may need some tweaking, but I have not yet spent the time to investigate this
          - e.g. another use is in running batch jobs, e.g. a [[https://www.jenkins.io/][Jenkins]] job:
            - suppose we have the same =pkgs.scm= and =channels.scm= in the project root
            - also suppose we want to batch run the R script =myscript.R=
            - assuming we have the same alias as above, we can run as (or config the Jenkins job to run this)
              #+begin_src shell
                work -- Rscript myscript.R
              #+end_src
            - of course you can run any command by putting them after =--=, and they would be run in the newly spawned shell
            - e.g. to run another shell script containing many commands
              #+begin_src shell
                work -- sh myscript.sh
              #+end_src
          - it should be clear that Guix can provide at least the same virtual environment like functionality, if not more useful and convenient
** Avoid dependency hell by including all dependencies
  - TODO
  - docker
  - flatpak, AppImage

* A closer look at Guix
** How you might have designed Guix

** Overview of the different parts of Guix

* Try out Guix

** In qemu virtual machine

** Install on existing GNU/Linux distribution (possibly in a VM)

** Install the Guix system, the GNU/Linux distribution built on the Guix package manager

* How to use Guix?

** As replacement of apt, yum, brew, etc

** As replacement of Python virtual environment using profiles

** Easy way to manage dependencies of multiple projects

*** A little demo

** Use Guix to create docker image

* Other related topics
  - use Guix in other OS than GNU/Linux
