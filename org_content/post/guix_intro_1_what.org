#+HUGO_BASE_DIR: ../../
#+HUGO_SECTION: post

#+HUGO_AUTO_SET_LASTMOD: nil

#+TITLE: Guix Introduction Part 1: What is Guix?

#+DATE: 2021-04-05

#+HUGO_TAGS: "Guix" "Functional Package Manager" "Reproducibility"
#+HUGO_CATEGORIES: "Guix"
#+AUTHOR:
#+HUGO_CUSTOM_FRONT_MATTER: :author "Peter Lo"

#+HUGO_DRAFT: true

This is the first part of a brief introduction to the Guix functional
package manager, and how it could be used to manage dependencies of
projects, much like virtual environments for Python, but with much
larger scope.

This is written in a way that I wish Guix was introduced to me back
when I first learnt it.

# summary

* What is Guix?

** Guix: functional package manager
Guix has the following characteristics:
   - [[https://guix.gnu.org/][Guix]] is in fact a package building system, being a good package manager is a side effect
     - inspired by the [[https://nixos.org/][Nix]] functional package manager
       - which is in turn partly inspired by functional programming, and by [[https://wiki.gentoo.org/wiki/Main_Page][Gentoo]]'s package management
     - to make the package building a /pure function/ and therefore more easily reproduced
   - designed to properly address the "dependency hell" problem
   - aims at reproducible builds
     - the /exact/ same set of packages could be reproduced at a later time or on a different machine (of the same architecture), by just using two small text files
   - allows atomic installation/uninstallation/upgrade of packages
     - each action may involve one or more packages, and is a *transaction*, i.e. either it succeeds as a whole, or does not succeed, there would not be half installed packages
   - allows easy rollback of install/uninstall/upgrade actions
     - each transaction results in new generation
     - can easily rollback to previous generations
     - so there is little fear of accidentally installing/uninstalling/upgrading the wrong packages
   - allows different versions of the "same" package to coexist and used by different pakcages, without conflict
   - encourages declarative package management
     - a set of packages can be specified in a *manifest file*, and can be installed in one transaction
   - currently only works on GNU/Linux
     - can be installed on any GNU/Linux distribution such as Debian, Ubuntu, Arch, etc
     - can coexist with the existing package manager of the distribution
   - allows each user to manage his/her own packages
     - without root privilege
     - without interferring other users
   - each user can have multiple *profiles* of packages
     - each profile has its own list of generations, and can be rolled back separately
   - allows easy creation of isolated environments with designated packages
     - useful for per-project dependency management
   - *Guix system* is a GNU/Linux distribution built on top of the Guix package manager
     - use a config file to declaratively specify the whole system, e.g. the system services, user accounts, etc


At this point, you may not think these characteristics are special if
you have not experienced the pains brought by dependency
management. Hopefully after reading this post you will have better
appreciation of why a package manager is useful and why Guix is a good
one due to these good characteristics.

** Basic concepts of packages and dependency
We first list out some concepts related to packages and dependency:
   - *package*:
     - loosely speakinig, a package is a collection of functionality that we are interested in, e.g.
       - a library of functions, e.g. the [[https://www.tidyverse.org/][tidyverse]] R package
       - some applications, e.g. the [[https://www.mozilla.org/en-US/firefox/browsers/][firefox]] web browser
       - command line programs, e.g. the [[https://github.com/BurntSushi/ripgrep][ripgrep]] command for fast grep search on contents of files
       - or just a set of documentation files
   - *package building*:
     - the final files in a package are often produced through a /building/ process from some sort of /source/ files
     - e.g.
       - =ripgrep= is written in the [[https://www.rust-lang.org/][Rust programming language]], and would need a Rust compiler to produce the program
       - some pdf documentations may be produced through the [[https://www.latex-project.org/][Latex]] typesetting system
       - an R package needs to be built, see https://bookdown.org/rdpeng/RProgDA/building-r-packages.html
     - some packages are very flexible, and allow specifying different options when building, resulting in functionally slightly different packages
       - e.g. some functions may be left out if it is considered not useful
       - e.g. some function could be provided by different *dependent packages*
     - building script:
       - most packages have some building process (e.g. a script or a makefile)
     - building environment:
       - some packages will automatically detect its environment to change building options
       - e.g. if some other package is absent, some functionality will be left out, but the building will still succeed
       - therefore, if the building environment is not properly isolated, the "same" building script may still result in different built package, depending on what other packages are present in the system
       - this is similar to programming where the output of a "function" depends not only on its inputs, but also on other global variables
   - *package version*:
     - strictly speaking, package version is just a name attached to a package, and the name could theoretically be arbitrary, although most package authors follow some conventions
     - e.g. a lot of packages follow the [[https://semver.org/][Semantic versioning]], briefly
       - a version number consists of three numbers, in the format of "MAJOR.MINOR.PATCH", e.g. "1.0.4", where each should be increment as follows
         - MAJOR: when you make incompatible API changes, where MINOR and PATCH could be reset to 0, e.g. from "1.2.3" to "2.0.0"
         - MINOR: when you add functionality in a backwards compatible manner, where PATCH could be reset to 0, e.g. from "1.2.3" to "1.3.0"
         - PATCH: when you make backwards compatible bug fixes, e.g. from "1.2.3" to "1.2.4"
     - NOTE:
       - normally, different versions will have some differences, although they may be small, or supposed to be /backward compatible/.
       - even for the same vesion number, the package may be functionally different if built differently, as mentioned above.
   - *dependency*:
     - loosely speaking, if a package A needs another package B to provide some functionality, then A /depends/ on B, i.e. B is a /dependency/ of A.
     - *direct/indirect dependency*:
       - often a package will list out its needed dependencies (possibly also the range of allowed versions of each dependency), either formally in some fixed format, or informally as free text in some readme
       - *direct dependency*: the dependencies listed for a package
       - *indirect dependency*: not direct dependency, but are (direct or indirect) dependencies of the direct dependencies
       - Why the distinction of direct and indirect dependency? Both are needed to fully capture the dependencies.
         - the distinction is useful mainly when the dependency updates
         - if package A directly depends on package B, presumably the developers of A knows which functionality of B is needed
         - if B is updated to B1, then the developers of A need only check whether the needed functionality is still provided by B1, and act accordinly, rather than checking each of the dependencies of B and B1 to see which are still needed.
     - *build-time/run-time dependency*:
       - *build-time dependency*: dependency needed for building a package
         - e.g. a particular version =gcc= for compiling a program
         - e,g, *statically linked libraries*, i.e. those compiled into the program, so are needed at build-time
         - a build-time dependency may or may not be needed when the program is later run
       - *run-time dependency*: dependency needed for using the package, e.g. running the application
         - e.g. the *dynamically linked libraries*, i.e. the libraries will be loaded only when the program is run
         - nowadays, most programs use mostly dynamically linked libraries
         - NOTE: a dependency can be both build-time and run-time dependency
     - *optional dependency*: dependency that can be omitted for the package to build or run, but some functionality may be missing
       - e.g. [[http://www.inkscape.org/][inkscape]] can be built without the optional dependency =potrace=, just without bitmap tracing functionality.
       - in most *package manager* which mainly distribute binary packages, often most optional dependencies would be included to provide the most funcitonality
   - *dependency hell*:
     - roughly speaking, [[https://en.wikipedia.org/wiki/Dependency_hell][dependency hell]] refers to the problems caused by the dependency on specific versions of some packages.
     - dependency hell takes a few forms:
       - too many or long chains of dependencies:
         - this is only a problem if the dependencies have to be hunted down manually, which could become tedious very quickly
         - most package managers solve this by installing the dependencies when a package is installed
       - conflicting dependencies:
         - in many package manager (and default in dynamic library in Linux), minor versions are considered backward compatible, and for each package of the same major version, only the newest minor version is kept/used
         - if both package A and B depend on a package C, but A and B needs different minor versions of C to work correctly, then A and B have conflicts
         - this may happen if B is updated to B1 causing C to be updated to C1, therefore causing A to break, even if the older versions of the 3 packages previously coexisted and worked correctly.

           #+CAPTION: Dependency before updating B
           [[file:dep_before_update.png]]

           #+CAPTION: Dependency after updating B
           [[file:dep_after_update.png]]

         - in this case, it is clear that if we just let A to use the old C, and the new B1 to use the new C1, then A can work as before, and B can still be updated to B1.

           #+CAPTION: Ideal dependency after updating B
           [[file:dep_ideal_after_update.png]]

   - ways that code of package A can break if a dependency B updates to a supposingly /backward compatible/ minor version:
     - although most of the time updating a minor version does not cause problem, they might still cause breakage
     - e.g. suppose A depends on a function in B, there could be a few cases:
       - the function interface remains unchanged or adds optional parameters, but the implementation is changed:
         - A may rely on undocumented behavior of the function, which has changed in the new implementation, although the documented interface is still the same.
           - e.g. the old implementation may sort the output as a side effect, but not promised in the function interface, and A may have relied on the sorted order
         - the new implementation may have buggy edge case, causing A to break
         - the new implementation may expose a buggy edge case in A, causing A to break
   - *reproducible build*
     - it is desirable to have the /exact same versions/ of dependencies between testing and production systems, and preferably also for the development environment
     - it is therefore desirable to /reproduce/ the exact same set of packages on a different machine (of the same architecture) and/or at a different time
     - this could be achieved in two main ways:
       - record the set of versions of the (pre-built) packages, and reinstall when needed
         - e.g. python virtual environment mostly follow this paradigm
       - record the set of versions of the packages, and rebuild then when needed
         - this is similar to the previous one, with the difference that the package can be built from scratch if needed
         - e.g. Guix can rebuild package(s) through the set of package definitions with explicit dependencies information
           - Guix can simply download the pre-built package (called /substitute/ in Guix) when available
       - record the set of built packages and just copy them as a whole when needed
         - e.g. building a docker image to contain all needed packages
     - isolated building environment can help with reproduciblity
       - only the explicitly listed dependencies are visible in building, so that the building script will not depend on other packages unknowingly
   - reproducibility raises the question of /sameness/ of packages
     - the package name with version number /would be/ sufficient if each version if always built the same way with the same versions of dependencies
       - this is the strategy adopted by most package managers
     - a better way is to use the package name together with some kind of *hash*
       - not necessarily the hash /of/ the package itself, as we will see in later sections
       - but different contents of a package should produce different hashes
   - *hash*:
     - basically a (very large) integer calculated through a *hash function* on some input, e.g. a file
     - the calculated integer is in some fixed range, often written as a long hexadecimal string such as "730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525"
     - the input however often has not length limit
     - e.g. [[https://en.wikipedia.org/wiki/SHA-2][sha-256]], [[https://en.wikipedia.org/wiki/MD5][md5]]
     - desired properties of a good *hash function*:
       - the same input always produce the same hash, i.e. it is a /pure function/ in the mathematical sense
         - i.e. if two inputs produce different hashes, they /must be/ different
       - it is one-way
         - there is not efficient way to recover the original content just from the hash, other than trying all possible input to find those that give the same hash
       - even a slight change in the input causes drastically different hash
         - useful for identifying corruption or tampering of files
       - /low/ collision, i.e. different inputs /should/ produce different hashes
         - it is impossible to have /no/ collision unless the set of possible inputs is less than the set of possible outputs
     - note that one hash is enough to represent a web of connected things:
       - e.g.
         - if you have a few (ordered) inputs, you hash each of them, and write the hashes to a file, then you hash this file
         - this is still a deterministic hashing process
         - if any of the input is changed, its calculated hash will /most probably/ be different, so this file of hashes will be different, and consequently the final hash will be different
         - each of the input itself could contain hashes of more inputs recursively, so a web of things could be represented as one hash
         - this technique is also used in [[https://git-scm.com/][git]] version control system to link the commits together
         - the same technique could be used to hash the (direct) dependencies of a package, and therefore one hash could represent all the direct and indirect dependencies of a package

* A closer look at Guix
** Overview of the different parts of Guix
   We introduce the main parts of guix through a hypothetical Q&A, so
   that the parts are better motivated, and it is clearer how each
   parts fits into the whole.

TODO: add a diagram for overview of parts of Guix

   - Q: We are making a package manager to help us manage
     dependencies, where should we start?
     - A: Eventually a package needs to be built, we may as well make
       a package building tool which also manages dependencies.
   - Q: Each package has some way of building, e.g. the usual
     configure-make or cmake for most C or C++ projects, Python
     packages have their usual way of building, R package can be built
     by =R CMD build=, so we can have commands for each type of build
     systems to reduce repetitive work, so that for each package we
     only specify the unique parts and we should be done?
     - A:It is a good idea to have commands for different build
       systems, so we can have =gnu-build-system= (for configure-make
       builds), =cmake-build-system=, =python-build-system=,
       =r-build-system=, =julia-build-system=, =texlive-build-system=,
       =emacs-build-system=, =maven-build-system=,
       =linux-module-build-system=, =node-build-system= and others.
     - A: But packages often have dependencies (which is the whole
       point of package manager), so we should also specify the
       dependencies of each package, separately for build-time and
       run-time dependencies. It is also nice to have a /package
       definition/ to specify these in a sort of declarative way. We
       may also add some metadata to the package definition such as
       package name, version number, a short description.
     - A: An example of package definition is:
       #+begin_src scheme
         (define-public r-jsonlite
           (package
             (name "r-jsonlite")
             (version "1.7.2")
             (source (origin
                       (method url-fetch)
                       (uri (cran-uri "jsonlite" version))
                       (sha256
                        (base32
                         "1lhzcpz9clwq04i5m6jzkvw9x03pwlqrixv4l9xzchjr8d84nd86"))))
             (build-system r-build-system)
             (native-inputs
              `(("r-knitr" ,r-knitr)))
             (home-page "https://arxiv.org/abs/1403.2805")
             (synopsis "Robust, high performance JSON parser and generator for R")
             (description
              "The jsonlite package provides a fast JSON parser and generator optimized
         for statistical data and the web.  It offers flexible, robust, high
         performance tools for working with JSON in R and is particularly powerful for
         building pipelines and interacting with a web API.  In addition to converting
         JSON data from/to R objects, jsonlite contains functions to stream, validate,
         and prettify JSON data.  The unit tests included with the package verify that
         all edge cases are encoded and decoded consistently for use with dynamic data
         in systems and applications.")
             (license license:expat)))
       #+end_src
   - Q: So with the metadata, we can first ensure the dependencies are
     available and build them if necessary, before building our target
     package. But how to prevent incorrectly specified dependencies?
     - A: To avoid unspecified dependencies, the package can be built
       in an isolated environment (e.g. a chroot environment) where
       only the explicitly specified dependencies are available, so
       that if a needed dependency is not specified, the package will
       not build successfully, so that we will be aware of the problem
       at package development time.
     - A: Overly specified dependencies is less of a problem, because
       the target package can still be built if there are extra
       packages available. So one way is to ignore this problem, and
       simply let package definition writer add dependencies as needed
       while testing the build.
   - Q: How to name the package in a unique way? Can we use the
     package name and the version number, e.g. =r-jsonlite-1.7.2=?
     - A: Even for the same version of a package, the building
       parameters (e.g. compiler options) or available dependencies
       (e.g. optional dependencies, some of which can be turned on or
       off when building) can still result in different package
       artefact. If we always use a canonical building parameters and
       options, then using only the name and version would
       suffice. But it would be good to have a much finer-grained
       identify for each exact version of each package, and it can be
       used for other purposes such as caching.
     - A: We can pre-pend some kind of hash calculated from the inputs (or
       their hashes) to the build process, including:
       - source
       - dependencies
       - build system and parameters such as compiler options
       - environment variables to be defined
       - target system type
       - where to store the built package
     - A: The hash transitively encodes the exact versions of package
       and all its direct and indirect dependencies.
     - A: an example of such a unique name is
       =2am1s5hqgkzxzbyvcfbhxq72diny117q-r-yaml-2.2.1=
   - Q: Maybe we just calculate the hash of the built artefacts? Oh,
     but then we will always need to build the package in order to
     calculate the hash, which greatly reduces the usefulness of the
     hash?
     - A: Instead of calculating the hash of the final built artefact,
       we can produce a /derivation/ which has sufficient details to
       exactly *reproduce* the package when built. The derivation can be
       produced efficiently, without building the package. As long as
       the build process is *deterministic*, the hash of the derivation
       is as good as the hash of the final built artefacts in uniquely
       identifying the exact version of the package.
     - A: an example of derivation is (note that it is in a canonical
       way without unnecessary whitespace):
       #+begin_src text
         Derive([("out","/gnu/store/2am1s5hqgkzxzbyvcfbhxq72diny117q-r-yaml-2.2.1","","")],[("/gnu/store/07byz0yy984h3d8mkbsdxml18wp1nac7-make-4.3.drv",["out"]),("/gnu/store/24lms3l4ylxwb7ddrja4iq92syzya7xd-yaml_2.2.1.tar.gz.drv",["out"]),("/gnu/store/5bbi7iwazfrvc9fg8y4fg4lp6j01d3x3-grep-3.4.drv",["out"]),("/gnu/store/8psdnbc4jhcz3k0ghkd9ha5mdm2r4pd0-bzip2-1.0.8.drv",["out"]),("/gnu/store/8vfk6231k05m6ik6k0dfk5lvm8n7822y-gzip-1.10.drv",["out"]),("/gnu/store/9whhajxkjkxb9vwdb0z5ashcmigj81pa-coreutils-8.32.drv",["out"]),("/gnu/store/afj3j7ghv6zm1iq6p3m5dbqsnrriy9ds-bash-minimal-5.0.16.drv",["out"]),("/gnu/store/b5nnbpgkvgdpzgvj67539ylcaqacj90l-guile-3.0.2.drv",["out"]),("/gnu/store/bhs8mjdhm37wk16qg8jzn9fdcgmllj50-diffutils-3.7.drv",["out"]),("/gnu/store/fdmz5blhzfczkpjb9jj6bdbhqlpv3i7l-gcc-7.5.0.drv",["out"]),("/gnu/store/fvi7sqvk9m1w93xaf8565ai7742zqc2i-xz-5.2.4.drv",["out"]),("/gnu/store/h1vn41niaqhm75b4syvl1cg7f9rbzc0z-glibc-2.31.drv",["out","static"]),("/gnu/store/jd1fm999bf0k2vqlgzqbcacbjrqmai11-module-import-compiled.drv",["out"]),("/gnu/store/mkq3s7av2l1vhcxns84k5q3j7r92imxm-patch-2.7.6.drv",["out"]),("/gnu/store/mm8flcvndb2mr53xhf2zilx263s88bf3-findutils-4.7.0.drv",["out"]),("/gnu/store/mv12ligm0jzz762rh46i09iddhxvaim2-ld-wrapper-0.drv",["out"]),("/gnu/store/n0h0fjvxk93jzl8jp9n6p1g52dlj1m6l-gawk-5.0.1.drv",["out"]),("/gnu/store/pqyd0rq2aqx8rbgdgjzpcjizhq6wzhv9-file-5.38.drv",["out"]),("/gnu/store/qlf9sxffyy9h6cw4zm5jnbilzbimgbil-binutils-2.34.drv",["out"]),("/gnu/store/r7i0jcdvnwkm2k1h4wx42w5m9fnsanmq-glibc-utf8-locales-2.31.drv",["out"]),("/gnu/store/vchlnxh5gsi6m12jk5x66dxswxx32h61-sed-4.8.drv",["out"]),("/gnu/store/y3mdvds4kj82mk76f4rfqlv9n5m19n44-r-minimal-4.0.3.drv",["out"]),("/gnu/store/y9d0im1z8f4bvv7a74s0yycl3d0z4yh0-linux-libre-headers-5.4.20.drv",["out"]),("/gnu/store/zp2jf7vmqm0q386d0snlmhfdsgykdv2a-tar-1.32.drv",["out"])],["/gnu/store/2arrpvah49pfchmlfnppaynwhjx4gw3x-module-import","/gnu/store/rv0awncdchqfd8j32dqjr77s0x44f24r-r-yaml-2.2.1-guile-builder"],"x86_64-linux","/gnu/store/0m0vd873jp61lcm4xa3ljdgx381qa782-guile-3.0.2/bin/guile",["--no-auto-compile","-L","/gnu/store/2arrpvah49pfchmlfnppaynwhjx4gw3x-module-import","/gnu/store/rv0awncdchqfd8j32dqjr77s0x44f24r-r-yaml-2.2.1-guile-builder"],[("GUILE_LOAD_COMPILED_PATH","/gnu/store/k2xsq0ab5yvjhs8km8d74ayardb2n22h-module-import-compiled"),("out","/gnu/store/2am1s5hqgkzxzbyvcfbhxq72diny117q-r-yaml-2.2.1")])
       #+end_src
   - Q: by "reproduce" do you mean building the bit-by-bit identical artefacts?
     - A: Yes, Guix aims at bit-by-bit reproduciblity. Since we are
       controlling also the build dependencies (e.g. the exact
       compiler version) and building parameters, for a given
       architecture (e.g. x86_64), it ought to be able to build the
       exact same artefacts at a different time, possibly on a
       different machine with the same architecture.
     - A: Reproducibility helps with testing, because once a package
       has been tested in an environment, we have high confidence that
       it will behave the same in the same environment, even if it was
       built at a later time.
     - A: But this strict reproducibility depends on having a
       deterministic build process using the derivation. So the build
       cannot for example involve randomness, or write current
       timestamp in any of the build artefact. So for some packages
       the build system may need to adjusted for remove these. Guix
       provides hooks to specify in the package definition any
       adjustments of the different building phases of any build
       system.
   - Q: From the above example of package definition, the dependency
     specifies only the package name but not the exact version?
     - A: Yes, when the dependency only lists the name of the package,
       the exact version is implicit, i.e. it is whatever the version
       that is built together with the target package.
     - A: Most package managers have a ability to specify version
       ranges for dependencies, and a constraint solver is needed to
       determine whether a certain set of packages have conflicts. But
       to my knowledge this is not available in Guix. In Guix, it is
       assumed that when a package definition is developed, it is
       tested against a particular version of package definitions as
       dependencies. If none of the package definition of direct or
       indirect dependency is changed, the package can be exactly
       reproduced. If any of the depdency was later changed, depending
       on how many packages it may affect, different levels of testing
       would be performed to minimize the adverse effect of breaking
       other packages.
   - Q: The set of package definitions is critical, how to manage them in a sane way?
     - A: The package definitions can be organized as a set of files,
       each containing a set of related packages (e.g. one file for R
       CRAN packages, one file for Python PyPi packages, etc). In Guix
       these files are in fact code, so it is a good idea to manage
       them with source control system such as git.
     - A: In Guix, a repository of package definitions is maintained
       as a git repository, the official one is
       https://git.savannah.gnu.org/git/guix.git
     - A: Another benefit of maintaining package definitions in git
       repository is that a git commit represents a snapshot of all
       the package definitions at a time point, which allows easy
       pinning of package versions of a set of packages.
   - Q: So the set of packages form a graph with the dependency links,
     is there a way to query this web programmatically?
     - A: Yes, the dependencies among the packages form a graph (which
       should be a direct acyclic graph, otherwise we would have
       cyclic dependency) in form of Guile (a dialect of Scheme) data
       structure, and Guix provides programmatical access to this
       graph for various kinds of manipulations, e.g.:
       - query the direct and indirect dependencies of a set of
         packages
       - query the set of packages that depend on a package, e.g. to
         see which package may be affect if a package is updated
       - plot the dependency graph of a set of packages
   - Q: Can I maintain my private list of packages?
     - A: Guix allows using multiple channels at the same time, and
       creating a channel is basically as simple as creating a git
       repository. So you can easily create your own channel(s) as a
       (public or private) git repository, for whatever package
       definitions that you want to maintain, as long as the computer
       where Guix is installed can access the repository. Moreoever,
       you can also add third-party channels (similar to PPA in Debian
       based distribution) for extra packages.
     - A: The channels of Guix is recorded at a text file, including
       the current commit of each channel. This file facilitates
       version controlling the states of the channels.
     - A: An example of a file with two channels is:
       #+begin_src scheme
         (list (channel
                 (name 'nonguix)
                 (url "https://gitlab.com/nonguix/nonguix")
                 (commit
                   "51dc6fb07ea1984f2ce55a44b0ce998200fb0e5c")
                 (introduction
                   (make-channel-introduction
                     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
                     (openpgp-fingerprint
                       "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
               (channel
                 (name 'guix)
                 (url "https://git.sjtu.edu.cn/sjtug/guix.git")
                 (commit
                   "0efd68681dcec50d445a4fd080c315b999164828")
                 (introduction
                   (make-channel-introduction
                     "9edb3f66fd807b096b48283debdcddccfea34bad"
                     (openpgp-fingerprint
                       "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA")))))
       #+end_src
   - Q: But I do not want to build the package from source all the
     time, can I download pre-built binary instead?
     - A: Of course, it is possible to download pre-built packages
       called /substitution/ from server. And this is where the
       package hash comes into handy, because it serves as a key to
       identify the package; When a package is wanted either directly
       or indirectly, roughly Guix does the following:
       - check whether the local =/gnu/store= already has that exact
         package. If so, then no further action is needed for the
         package.
       - if the package is not in =/gnu/store= yet, then check whether
         there is a pre-built substitue from the official substitution
         server (or additionally configured server(s)). If so, then
         download the pre-built package.
       - if the package is not in any of the substitution servers,
         then build the package locally.
     - A: You may also create your own substitution server, which
       roughly amounts to having a machine with Guix, then running
       =guix publish=, check [[https://guix.gnu.org/manual/en/html_node/Invoking-guix-publish.html#Invoking-guix-publish][Invoking guix publish]] for details.
   - Q: Can I easily shared built packages within my network, so that
     worker nodes need not built the packages themselves?
     - A: Yes, you can have one or more machines in your network that
       runs =guix publish=, and add it as a substitution server in the
       Guix of the work nodes.
   - Q: Since in Guix each exact version of a package has an
     associated hash, maybe we can use this to avoid conflicting
     dependency versions?
     - A: Of course. The main problem with dynamic dependency is that
       they are specified with only package name and major version,
       and resolved at run-time. If another package using the same
       dependency requires a newer version of it, then it will be
       updated, and other packages which depend on it will now resolve
       to the new version, which may cause breakage, even though the
       newer version is supposed to be backward compatible.
     - A: The stable and conservative way of managing dependency is to
       ensure the dependencies always resolve to the same exact
       version as at built time, so that we need not worry it suddenly
       breaks due to any other (un)related updates. In Guix, the
       derivation has already pinned the exact versions of the
       dependencies using the hash, and in building the package, Guix
       build system try to hard-code the paths of the dependencies (to
       =/gnu/store=) as much as possible, so it is similar to "static
       linking".
     - A: Note that if some direct or indirect depedency is updated,
       and we use the same package definition to build the package,
       the resulting hash will be different (unless we have a hash
       collision which is exceedingly rare).
   - Q: This "static linking" does not sound good, are we giving up
     the benefits of dynamically linked libraries, namely the same
     code need only has one copy in memory, to be shared between many
     different programs, which is useful for GUI programs which depend
     on the widget library.
     - A: Whether a library is dynamically or statically linked
       depends on the options in linking. The Guix way is "static",
       but still uses dynamic linking if the library is dyanmically
       linked. Therefore, if /exactly/ the same dynamic library is a
       dependency of several different programs, at run-time, the same
       dynamic library is still only loaded into memory once and
       shared.
     - A: On the other hand, if different programs need to use
       different minor versions of the same dynamic library, then
       Guix's way just works with no other handling needed.
   - Q: How about easy updating of dependency, e.g. to fix security vulnerability?
     - A: In true static linking, if a library needs to be updated
       (e.g. due to security vulnerability), all the packages that
       directly or indirectly depend on the library need to be
       rebuilt. Guix is similar, with the difference that Guix
       carefully and accurately tracks the dependencies, so
       re-building is less of a hassle, and only takes some time. Also
       note that, the rebuilt packages will have different hashes, and
       the updated dependencies are again carefully and accurately
       tracked.
     - A: But it is true that having to rebuilt packages could be
       inconvenient, especially for lower level libraries that is
       dependency of many other packages (e.g. glibc). That's why Guix
       allowing [[https://guix.gnu.org/ru/blog/2020/grafts-continued/][grafting]], which basically allows replacing some
       dependencies without rebuilding the whole package, i.e. reusing
       most of other components, if applicable. Also see [[https://guix.gnu.org/manual/en/html_node/Security-Updates.html][Security
       Updates]] for more descriptions. This may save substantial time
       in rebuilding packages, and is pretty much the same as
       replacing a dynamic library, except that the dependencies are
       still accurately tracked. Also note that grafted packages have
       different hashes from rebuilt package.
   - Q: so all my built packages are in =/gnu/store= with a long path
     with package hash, and they (mostly) will statically link to each
     other, but the long paths seems very inconvenient in using,
     E.g. how do I execute =emacs=?
     - A: Of course it is extremely inconvenient to type
       =/gnu/store/ccg56ki80zshgkpbbaabh9dd6frmfxc3-emacs-27.2/bin/emacs=
       to invoke emacs, so Guix uses a bunch of symbolic links and
       suitably setting the =PATH= environment so that you can still
       conveniently invoke emacs just by typing =emacs= in your shell.
     - A: In a typical Linux, the program binaries are installed in
       locations such as =/bin=, =/usr/bin=, etc, and these paths are
       added to the =PATH= environment variables, so that we can
       simply type the program name to invoke a program. But putting
       all binaries at a global location causes trouble when we want
       different version of the same program to be installed (and they
       have the same name, think different versions of R, the
       executable are all called =R=) and choose which to use at
       different times.
     - A: In order to avoid this problem, Guix uses the idea of
       /profile/ to hold a set of packages, which is essentially a
       directory containing subdirectories such as =bin= to hold
       symbolic links to binaries, =etc=, =include=, =lib=, etc which
       holds (symbolic links) to things for the set of
       packages. E.g. currently on my system the default profile
       =/home/peter/.guix-profile= points to
       =/gnu/store/iw0r9yprbhsy5vlqp1dkg7maajnf3hkb-profile= (found by
       =readlink -f /home/peter/.guix-profile=). And we can have a peek of what is inside:
       #+begin_src shell
         $ ls -l /gnu/store/iw0r9yprbhsy5vlqp1dkg7maajnf3hkb-profile
         total 164
         dr-xr-xr-x  2 root root 36864 Jan  1  1970 bin
         dr-xr-xr-x  4 root root  4096 Jan  1  1970 etc
         dr-xr-xr-x  2 root root  4096 Jan  1  1970 include
         dr-xr-xr-x  7 root root 12288 Jan  1  1970 lib
         dr-xr-xr-x  2 root root  4096 Jan  1  1970 libexec
         -r--r--r--  2 root root 89125 Jan  1  1970 manifest
         dr-xr-xr-x  2 root root  4096 Jan  1  1970 sbin
         dr-xr-xr-x 19 root root  4096 Jan  1  1970 share
         lrwxrwxrwx  7 root root    61 Jan  1  1970 var -> /gnu/store/xnrw9pmw6zjc2x7f7w9bzq0sqjx9cbrl-openssh-8.5p1/var

         $ tree /gnu/store/iw0r9yprbhsy5vlqp1dkg7maajnf3hkb-profile | head -n 20
         /gnu/store/iw0r9yprbhsy5vlqp1dkg7maajnf3hkb-profile
         ├── bin
         │   ├── a2ping -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/a2ping
         │   ├── a5toa4 -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/a5toa4
         │   ├── adhocfilelist -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/adhocfilelist
         │   ├── afm2afm -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/afm2afm
         │   ├── afm2pl -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/afm2pl
         │   ├── afm2tfm -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/afm2tfm
         │   ├── ag -> /gnu/store/bk09ij4jxmpvxij0q3k2022ivrj5mfag-the-silver-searcher-2.2.0/bin/ag
         │   ├── aleph -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/aleph
         │   ├── allcm -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/allcm
         │   ├── allec -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/allec
         │   ├── allneeded -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/allneeded
         │   ├── arara -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/arara
         │   ├── arlatex -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/arlatex
         │   ├── authorindex -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/authorindex
         │   ├── autoinst -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/autoinst
         │   ├── autopep8 -> /gnu/store/isb01kkmcx4x9b4b4hc86z3ayk8659za-python-autopep8-1.5.3/bin/autopep8
         │   ├── autosp -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/autosp
         │   ├── axohelp -> /gnu/store/rnk9lj36z59ikmj4izs3r0knn0klkig2-texlive-20190410/bin/axohelp

       #+end_src
       We ses that the programs inside =bin= of the profile are really
       symbolic links to the real binary in the package in
       =/gnu/store=.  And therefore if my =PATH= contains
       =/home/peter/.guix-profile/bin=, I can use the programs in the
       profile just as those installed globally. Note that the real
       profile directory is also in =/gnu/store= with a hash, so if
       you install a different set of packages, the real path will be
       different.
   - Q: But then what advantage does a profile provides? Oh, "most
     problems in computer science can be solved with one more level of
     indirection", since profiles are behind at least one level of
     symbolic links, that means we can have multiple profiles for
     different sets (and versions) of packages, to be used either
     independently or together, by setting =PATH= and relatedly
     environment variables suitably, right? I guess that's how Guix
     provides the generation and roll-back features?
     - A: Exactly. Also, when we make any install/upgrade/remove
       actions on a profile, essentially we are asking for a different
       set of packages, so it will have a different real directory
       under =/gnu/store= with its own hash, and we can make a new
       symbolic link for it (whether the set of packages have already
       been created or not), and give it a new generation number,
       while /keeping/ the symbolic link for the previous
       generation. This way, we can easily /roll-back/ to the previous
       set of packages by just changing a symbolic link. This removes
       a lot of trouble of accidentally upgrading packages and
       breaking your workflow.
     - A: Moreover, since a symbolic link is cheap, we can easily
       create as many as we like, and each profile can have its own
       generation numbers, and be changed separately. There is great
       flexibility in how the profiles can be used. Some profiles can
       be used together if we put their =bin= directories in =PATH=;
       or some profiles can be meant to be used separately, activated
       only when needed, much like virtualenv in Python. The profile
       organization is entirely up to the user. For example, currently
       on my system I have the default profile for my frequently used
       tools such as emacs and many emacs packages, a separate profile
       for data science related packages such as R and R packages.
   - Q: Given that the =/gnu/store= is a global location for all the
     packages, do I need root privilege to install package in Guix?
     - A: No, each user can create as many profiles as he or she
       likes, because the default profile is put under the user home
       directory, and extra profiles can be placed basically wherever
       the user likes. Although =/gnu/store= is the global cache of
       all the packages and other stuffs, it is meant to be
       /immutable/ from the perspective of normal user (i.e. normal
       user cannot modify =/gnu/store= directly), so can be shared
       with different users and profiles. And writing to the
       =/gnu/store= is managed by the Guix daemon, so that its
       consistency can be maintained.
     - A: When a user do any actions that need to update =/gnu/store=
       (e.g. downloading a pre-built package, or creating a profile
       with a different set of packages), the =guix= command will
       communicate with the Guix daemon as needed. Therefore, even on
       a shared system such as a server, Guix allows each user to
       install his or her own sets of packages, organized in however
       many profiles desired, and those packages that are exactly the
       same can still be safely shared.
   - Q: can I have two different versions of a package installed at the same time?
     - A:
   - Q: what about profiles?
   - Q: how does Guix provide roll-back?
   - Q: how to pin versions of packages?
   - Q: what about the "transactional" part?
   - Q: what about interruption when installing packages?
   - Q: what about temporary environment of a set of packages?
   - Q: what if my different projects need different versions and sets of packages? how to ensure different projects do not have conflicts?

TODO


* What's next?
In this first part we had a look at what Guix is, next time we will
discuss why bother with Guix when there are alternatives that solve
similar problems.
